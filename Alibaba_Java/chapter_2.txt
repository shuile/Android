二、异常日志
	(一)异常处理
		1、Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch的方式来处理，比如：NullPointException。IndexOutOfBoundsException等等。
			说明：无法通过预检查的异常除外，例如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。
		2、异常不要用来做控制流程，条件控制。
			说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。
		3、catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何都不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。
			说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。
		4、捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。
		5、有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。
		6、finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。
			说明：如果JDK7及以上，可以使用try-with-resources方式。
		7、不要在finally块中使用return。
			说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢掉try块中的返回点。
		8、捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。
			说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。
		9、在调用RPC、二方包、或动态生成类的相关方法时捕捉异常必须使用Throwable类进行拦截。
			说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译是正确的，但在代码运行期时，会抛出NoSuchMethodError。
		10、方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下回返回null值。
			说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。
		11、放置NPE，是程序员的基本修养，注意NPE产生的场景：
			a. 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。
			b. 数据库的查询结果可能为null。
			c. 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。
			d. 远程调用返回对象时，一律要求进行空指针判断，放置NPE。
			e. 对于Session中获取的数据，建议进行NPE检查，避免空指针。
			f. 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。
		12、定义时区分unchecked/checked异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用业务含义的自定义异常。推荐业界已定义的自定义异常。
		13、对于公司外的http/api开放接口必须使用"错误码"；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用result方式，封装isSuccess()方法、"错误码"、"错误简短信息"。
			说明：关于RPC方法返回方式使用Result方式的理由：
				a. 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。
				b. 如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。
		14、避免出现重复的代码(Don't Repeat Yourself)，即DRY原则。
			说明：随意赋值和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至组件化。

	(二)日志规约
		1、应用中不可直接使用日志系统(Log4j、Logback)中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。
		2、所有日志文件至少保存15天，因为有些异常具备以"周"为频次发生的特点。网络运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日志不少于6个月。
		3、应用中的扩展日志(如打点、临时监控、访问日志等)命名方式：appName_longType_longName.log。longType：日志类型，如：stats/monitor/access等；logName：日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。
			说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开放人员查看，也便于通过日志对系统进行及时监控。
		4、在日志输出时，字符串变量之间的拼接使用占位符的方式。
			说明：因为String字符串的拼接会使用StringBuilder的append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。
		5、对于trace/debug/info级别的日志输出，必须进行日志级别的开关判断。
			说明：虽然在debug(参数)的方法体内第一行代码isDisabled(Level.DEBUG_INT)为真时(Slf4j的常见实现Log4j和Logback)，就直接return，但是参数可能会进行字符串拼接运算。此外，如果debug(getName())这种参数内有getName()方法调用，无谓浪费方法调用的开销。
		6、避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。
		7、异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws网上抛出。
		8、谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。
			说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看嘛？看这条日志你能做什么？能不能给问题排查带来好处？
		9、可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。
			说明：注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。
		10、尽量用英文描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。